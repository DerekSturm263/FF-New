// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
// </auto-generated>

using System;
namespace Quantum.Prototypes.Unity {
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(Quantum.AIData))]
  public class AIData_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.AIData_Prototype> {
    [Quantum.LocalReference]
    public global::EntityPrototype Target;
    public Quantum.Prototypes.Goal_Prototype CurrentGoal;
    public Photon.Deterministic.FP TimeSinceAction;
    public Photon.Deterministic.FP TimeSinceTargetSwitch;

    public sealed override Quantum.Prototypes.AIData_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.AIData_Prototype();
      converter.Convert(this.Target, out result.Target);
      result.CurrentGoal = this.CurrentGoal;
      result.TimeSinceAction = this.TimeSinceAction;
      result.TimeSinceTargetSwitch = this.TimeSinceTargetSwitch;
      return result;
    }
  }
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(Quantum.CharacterController))]
  public class CharacterController_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.CharacterController_Prototype> {
    public Quantum.AssetRefBehavior Behavior;
    public Quantum.AssetRefMovementSettings Settings;
    public Quantum.QBoolean CanInput;
    public Quantum.Prototypes.Colliders_Prototype NearbyColliders;
    public System.Int32 MovementDirection;
    public Quantum.Prototypes.Direction_Prototype DirectionEnum;
    public Photon.Deterministic.FPVector2 DirectionValue;
    public Quantum.AssetRefPlayerState CurrentState;
    public Quantum.AssetRefPlayerState NextState;
    public Quantum.Prototypes.StatesFlag_Prototype PossibleStates;
    public System.Int32 StateTime;
    public System.Int32 NextStateTime;
    public Quantum.Prototypes.Input_Prototype LastFrame;
    public Quantum.QBoolean StartedInAir;
    public Photon.Deterministic.FPVector2 OriginalPosition;
    public Quantum.Prototypes.KnockbackInfo_Prototype DeferredKnockback;
    public Quantum.Prototypes.KnockbackInfo_Prototype CurrentKnockback;
    public Quantum.Prototypes.KnockbackInfo_Prototype OldKnockback;
    public Photon.Deterministic.FP Velocity;
    public Photon.Deterministic.FP MovingLerp;
    public Quantum.QBoolean GroundedJump;
    public Quantum.Prototypes.JumpType_Prototype JumpType;
    public System.Int16 JumpCount;
    public Quantum.QBoolean GroundedDodge;
    public Quantum.Prototypes.DodgeType_Prototype DodgeType;
    public System.Int16 DodgeCount;
    public Quantum.QBoolean IsThrowing;
    public Quantum.QBoolean HasSubWeapon;
    public Photon.Deterministic.FP ThrowMultiplier;
    public System.Int32 HeldAnimationFrameTime;
    public System.Int32 MaxHoldAnimationFrameTime;
    public System.Int32 HoldButton;
    public Quantum.QBoolean ButtonHeld;
    public Photon.Deterministic.FPVector2 ApplyPhysicsPosition;
    public Quantum.QBoolean PressedButton;
    public Quantum.QBoolean IsReady;
    public Photon.Deterministic.FP ReadyTime;
    public System.Int32 UltimateTime;
    [Quantum.LocalReference]
    public global::EntityPrototype DigitalDouble;

    public sealed override Quantum.Prototypes.CharacterController_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.CharacterController_Prototype();
      result.Behavior = this.Behavior;
      result.Settings = this.Settings;
      result.CanInput = this.CanInput;
      result.NearbyColliders = this.NearbyColliders;
      result.MovementDirection = this.MovementDirection;
      result.DirectionEnum = this.DirectionEnum;
      result.DirectionValue = this.DirectionValue;
      result.CurrentState = this.CurrentState;
      result.NextState = this.NextState;
      result.PossibleStates = this.PossibleStates;
      result.StateTime = this.StateTime;
      result.NextStateTime = this.NextStateTime;
      result.LastFrame = this.LastFrame;
      result.StartedInAir = this.StartedInAir;
      result.OriginalPosition = this.OriginalPosition;
      result.DeferredKnockback = this.DeferredKnockback;
      result.CurrentKnockback = this.CurrentKnockback;
      result.OldKnockback = this.OldKnockback;
      result.Velocity = this.Velocity;
      result.MovingLerp = this.MovingLerp;
      result.GroundedJump = this.GroundedJump;
      result.JumpType = this.JumpType;
      result.JumpCount = this.JumpCount;
      result.GroundedDodge = this.GroundedDodge;
      result.DodgeType = this.DodgeType;
      result.DodgeCount = this.DodgeCount;
      result.IsThrowing = this.IsThrowing;
      result.HasSubWeapon = this.HasSubWeapon;
      result.ThrowMultiplier = this.ThrowMultiplier;
      result.HeldAnimationFrameTime = this.HeldAnimationFrameTime;
      result.MaxHoldAnimationFrameTime = this.MaxHoldAnimationFrameTime;
      result.HoldButton = this.HoldButton;
      result.ButtonHeld = this.ButtonHeld;
      result.ApplyPhysicsPosition = this.ApplyPhysicsPosition;
      result.PressedButton = this.PressedButton;
      result.IsReady = this.IsReady;
      result.ReadyTime = this.ReadyTime;
      result.UltimateTime = this.UltimateTime;
      converter.Convert(this.DigitalDouble, out result.DigitalDouble);
      return result;
    }
  }
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(Quantum.ChildParentLink))]
  public class ChildParentLink_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.ChildParentLink_Prototype> {
    [Quantum.LocalReference]
    public global::EntityPrototype Parent;
    public Photon.Deterministic.FPVector3 LocalPosition;
    [Quantum.Inspector.DegreesAttribute()]
    public Photon.Deterministic.FPVector3 LocalRotation;

    public sealed override Quantum.Prototypes.ChildParentLink_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.ChildParentLink_Prototype();
      converter.Convert(this.Parent, out result.Parent);
      result.LocalPosition = this.LocalPosition;
      result.LocalRotation = this.LocalRotation;
      return result;
    }
  }
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(Quantum.HitboxInstance))]
  public class HitboxInstance_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.HitboxInstance_Prototype> {
    public System.Int32 PathQueryIndex;
    [Quantum.LocalReference]
    public global::EntityPrototype Owner;
    [Quantum.Inspector.DynamicCollectionAttribute()]
    public Photon.Deterministic.FPVector2[] Positions = System.Array.Empty<Photon.Deterministic.FPVector2>();
    public Quantum.Prototypes.HitboxSettings_Prototype Settings;
    public Quantum.Shape2D Shape;
    public System.Int32 Lifetime;

    public sealed override Quantum.Prototypes.HitboxInstance_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.HitboxInstance_Prototype();
      result.PathQueryIndex = this.PathQueryIndex;
      converter.Convert(this.Owner, out result.Owner);
      result.Positions = this.Positions;
      result.Settings = this.Settings;
      result.Shape = this.Shape;
      result.Lifetime = this.Lifetime;
      return result;
    }
  }
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(Quantum.HurtboxInstance))]
  public class HurtboxInstance_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.HurtboxInstance_Prototype> {
    public Quantum.Prototypes.HurtboxSettings_Prototype Settings;
    public System.Int32 Index;
    [Quantum.LocalReference]
    public global::EntityPrototype Owner;

    public sealed override Quantum.Prototypes.HurtboxInstance_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.HurtboxInstance_Prototype();
      result.Settings = this.Settings;
      result.Index = this.Index;
      converter.Convert(this.Owner, out result.Owner);
      return result;
    }
  }
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(Quantum.ItemInstance))]
  public class ItemInstance_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.ItemInstance_Prototype> {
    public Quantum.AssetRefItem Item;
    [Quantum.LocalReference]
    public global::EntityPrototype Owner;
    [Quantum.LocalReference]
    public global::EntityPrototype Holder;
    [Quantum.LocalReference]
    public global::EntityPrototype Target;
    public Quantum.QBoolean FallState;
    public Quantum.QBoolean IsActive;
    public Photon.Deterministic.FP FallSpeed;
    public Photon.Deterministic.FP FallY;
    public Photon.Deterministic.FP ActiveTime;
    public System.Int32 Uses;

    public sealed override Quantum.Prototypes.ItemInstance_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.ItemInstance_Prototype();
      result.Item = this.Item;
      converter.Convert(this.Owner, out result.Owner);
      converter.Convert(this.Holder, out result.Holder);
      converter.Convert(this.Target, out result.Target);
      result.FallState = this.FallState;
      result.IsActive = this.IsActive;
      result.FallSpeed = this.FallSpeed;
      result.FallY = this.FallY;
      result.ActiveTime = this.ActiveTime;
      result.Uses = this.Uses;
      return result;
    }
  }
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(Quantum.PlayerLink))]
  public class PlayerLink_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.PlayerLink_Prototype> {
    public Quantum.PlayerRef Player;
    [Quantum.LocalReference]
    public global::EntityPrototype Entity;

    public sealed override Quantum.Prototypes.PlayerLink_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.PlayerLink_Prototype();
      result.Player = this.Player;
      converter.Convert(this.Entity, out result.Entity);
      return result;
    }
  }
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(Quantum.PlayerStats))]
  public class PlayerStats_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.PlayerStats_Prototype> {
    public Quantum.Prototypes.Build_Prototype Build;
    [Quantum.Inspector.MaxStringByteCountAttribute((Int32)30, "Unicode")]
    public System.String Name;
    public Quantum.Prototypes.FighterIndex_Prototype Index;
    public Quantum.AssetRefHurtboxSetup HurtboxSetup;
    public Quantum.Prototypes.ActiveWeaponType_Prototype ActiveWeapon;
    public Quantum.Prototypes.BattleStats_Prototype Stats;
    public Quantum.Prototypes.ApparelStats_Prototype ApparelStatsMultiplier;
    public Quantum.Prototypes.WeaponStats_Prototype WeaponStatsMultiplier;
    [Quantum.LocalReference]
    public global::EntityPrototype HeldItem;

    public sealed override Quantum.Prototypes.PlayerStats_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.PlayerStats_Prototype();
      result.Build = this.Build;
      result.Name = this.Name;
      result.Index = this.Index;
      result.HurtboxSetup = this.HurtboxSetup;
      result.ActiveWeapon = this.ActiveWeapon;
      result.Stats = this.Stats;
      result.ApparelStatsMultiplier = this.ApparelStatsMultiplier;
      result.WeaponStatsMultiplier = this.WeaponStatsMultiplier;
      converter.Convert(this.HeldItem, out result.HeldItem);
      return result;
    }
  }
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(Quantum.Stats))]
  public class Stats_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.Stats_Prototype> {
    [Quantum.Inspector.DynamicCollectionAttribute()]
    [Quantum.LocalReference]
    public global::EntityPrototype[] Hitboxes = System.Array.Empty<global::EntityPrototype>();
    [Quantum.Inspector.DictionaryAttribute()]
    [Quantum.Inspector.DynamicCollectionAttribute()]
    public DictionaryEntry_HurtboxType_EntityRef_Prototype[] Hurtboxes = System.Array.Empty<DictionaryEntry_HurtboxType_EntityRef_Prototype>();
    public System.Int32 IFrameTime;
    public Quantum.Prototypes.WellnessStats_Prototype CurrentStats;
    public Quantum.Prototypes.WellnessStats_Prototype StatsMultiplier;
    public Quantum.AssetRefStatusEffect StatusEffect;
    public System.Int32 StatusEffectTimeLeft;
    public Photon.Deterministic.FP StatusEffectMultiplier;
    public Quantum.QBoolean IsDead;
    public Quantum.QBoolean IsRespawning;

    public sealed override Quantum.Prototypes.Stats_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.Stats_Prototype();
      result.Hitboxes = System.Array.ConvertAll(this.Hitboxes, x => { converter.Convert(x, out Quantum.MapEntityId tmp); return tmp; });
      result.Hurtboxes = System.Array.ConvertAll(this.Hurtboxes, x => x.Convert(converter));
      result.IFrameTime = this.IFrameTime;
      result.CurrentStats = this.CurrentStats;
      result.StatsMultiplier = this.StatsMultiplier;
      result.StatusEffect = this.StatusEffect;
      result.StatusEffectTimeLeft = this.StatusEffectTimeLeft;
      result.StatusEffectMultiplier = this.StatusEffectMultiplier;
      result.IsDead = this.IsDead;
      result.IsRespawning = this.IsRespawning;
      return result;
    }
  }
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(System.Collections.Generic.KeyValuePair<Quantum.HurtboxType, Quantum.EntityRef>))]
  public class DictionaryEntry_HurtboxType_EntityRef_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.DictionaryEntry_HurtboxType_EntityRef_Prototype> {
    public Quantum.Prototypes.HurtboxType_Prototype Key;
    [Quantum.LocalReference]
    public global::EntityPrototype Value;

    public sealed override Quantum.Prototypes.DictionaryEntry_HurtboxType_EntityRef_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.DictionaryEntry_HurtboxType_EntityRef_Prototype();
      result.Key = this.Key;
      converter.Convert(this.Value, out result.Value);
      return result;
    }
  }
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(Quantum.PhysicsJoints3D))]
  public class PhysicsJoints3D_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.PhysicsJoints3D_Prototype> {
    [Quantum.Inspector.DynamicCollectionAttribute()]
    public Joint3D_Prototype[] JointConfigs = System.Array.Empty<Joint3D_Prototype>();

    public sealed override Quantum.Prototypes.PhysicsJoints3D_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.PhysicsJoints3D_Prototype();
      result.JointConfigs = System.Array.ConvertAll(this.JointConfigs, x => x.Convert(converter));
      return result;
    }
  }
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(Quantum.Physics3D.Joint3D))]
  public class Joint3D_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.Joint3D_Prototype> {
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("If the joint should be materialized with Enabled set to false, not being considered by the Physics Engine.")]
    public System.Boolean StartDisabled;
    [Quantum.Inspector.DisplayNameAttribute("Type")]
    [Quantum.Inspector.TooltipAttribute("The type of the joint, implying which constraints are applied.")]
    public Quantum.Physics3D.JointType3D JointType;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("A numerical tag that can be used to identify a joint or a group of joints.")]
    public System.Int32 UserTag;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("A Map Entity that the joint might be connected to.\nThe entity must have at least a transform component.")]
    [Quantum.LocalReference]
    public global::EntityPrototype ConnectedEntity;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The anchor point to which the joint connects to.\nIf a Connected Entity is provided, this represents an offset in its local space. Otherwise, the connected anchor is a position in world space.")]
    public Photon.Deterministic.FPVector3 ConnectedAnchor;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The anchor offset, in the local space of this joint entity's transform.\nThis is the point considered for the joint constraints and where the forces will be applied in the joint entity's body.")]
    public Photon.Deterministic.FPVector3 Anchor;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("Axis around which the joint rotates, defined in the local space of the entity.\nThe vector is normalized before set. If zeroed, FPVector3.Right is used instead.")]
    public Photon.Deterministic.FPVector3 Axis;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)2, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The frequency in Hertz (Hz) at which the spring joint will attempt to oscillate.\nTypical values are below half the frequency of the simulation.")]
    public Photon.Deterministic.FP Frequency;
    [Quantum.Inspector.RangeAttribute((Single)0, (Single)2)]
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)2, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("A dimensionless value representing the damper capacity of suppressing the spring oscillation, typically between 0 and 1.")]
    public Photon.Deterministic.FP DampingRatio;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("Automatically configure the target Distance to be the current distance between the anchor points in the scene.")]
    public System.Boolean AutoConfigureDistance;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)2, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("AutoConfigureDistance", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)2)]
    [Quantum.Inspector.TooltipAttribute("The distance between the anchor points that the joint will attempt to maintain.")]
    public Photon.Deterministic.FP Distance;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)1, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("AutoConfigureDistance", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)2)]
    [Quantum.Inspector.TooltipAttribute("The minimum distance between the anchor points that the joint will attempt to maintain.")]
    public Photon.Deterministic.FP MinDistance;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)1, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("AutoConfigureDistance", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)2)]
    [Quantum.Inspector.TooltipAttribute("The maximum distance between the anchor points that the joint will attempt to maintain.")]
    public Photon.Deterministic.FP MaxDistance;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("If the relative angle between the joint transform and its connected anchor should be limited by the hinge joint.\nSet this checkbox to configure the lower and upper limiting angles.")]
    public System.Boolean UseAngleLimits;
    [Quantum.Inspector.DrawIfAttribute("UseAngleLimits", (Int64)1, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The lower limiting angle of the allowed arc of rotation around the connected anchor, in degrees.")]
    public Photon.Deterministic.FP LowerAngle;
    [Quantum.Inspector.DrawIfAttribute("UseAngleLimits", (Int64)1, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The upper limiting  angle of the allowed arc of rotation around the connected anchor, in degrees.")]
    public Photon.Deterministic.FP UpperAngle;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("If the hinge joint uses a motor.\nSet this checkbox to configure the motor speed and max torque.")]
    public System.Boolean UseMotor;
    [Quantum.Inspector.DrawIfAttribute("UseMotor", (Int64)1, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The speed at which the hinge motor will attempt to rotate, in angles per second.")]
    public Photon.Deterministic.FP MotorSpeed;
    [Quantum.Inspector.DrawIfAttribute("UseMotor", (Int64)1, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The maximum torque produced by the hinge motor in order to achieve the target motor speed.\nLeave this checkbox unchecked and the motor toque should not be limited.")]
    public Photon.Deterministic.NullableFP MaxMotorTorque;

    public sealed override Quantum.Prototypes.Joint3D_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.Joint3D_Prototype();
      result.StartDisabled = this.StartDisabled;
      result.JointType = this.JointType;
      result.UserTag = this.UserTag;
      converter.Convert(this.ConnectedEntity, out result.ConnectedEntity);
      result.ConnectedAnchor = this.ConnectedAnchor;
      result.Anchor = this.Anchor;
      result.Axis = this.Axis;
      result.Frequency = this.Frequency;
      result.DampingRatio = this.DampingRatio;
      result.AutoConfigureDistance = this.AutoConfigureDistance;
      result.Distance = this.Distance;
      result.MinDistance = this.MinDistance;
      result.MaxDistance = this.MaxDistance;
      result.UseAngleLimits = this.UseAngleLimits;
      result.LowerAngle = this.LowerAngle;
      result.UpperAngle = this.UpperAngle;
      result.UseMotor = this.UseMotor;
      result.MotorSpeed = this.MotorSpeed;
      result.MaxMotorTorque = this.MaxMotorTorque;
      return result;
    }
  }
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(Quantum.PhysicsJoints2D))]
  public class PhysicsJoints2D_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.PhysicsJoints2D_Prototype> {
    [Quantum.Inspector.DynamicCollectionAttribute()]
    public Joint2D_Prototype[] JointConfigs = System.Array.Empty<Joint2D_Prototype>();

    public sealed override Quantum.Prototypes.PhysicsJoints2D_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.PhysicsJoints2D_Prototype();
      result.JointConfigs = System.Array.ConvertAll(this.JointConfigs, x => x.Convert(converter));
      return result;
    }
  }
  [System.SerializableAttribute()]
  [Quantum.Prototypes.PrototypeAttribute(typeof(Quantum.Physics2D.Joint))]
  public class Joint2D_Prototype : Quantum.PrototypeAdapter<Quantum.Prototypes.Joint2D_Prototype> {
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("If the joint should be materialized with Enabled set to false, not being considered by the Physics Engine.")]
    public System.Boolean StartDisabled;
    [Quantum.Inspector.DisplayNameAttribute("Type")]
    [Quantum.Inspector.TooltipAttribute("The type of the joint, implying which constraints are applied.")]
    public Quantum.Physics2D.JointType JointType;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("A numerical tag that can be used to identify a joint or a group of joints.")]
    public System.Int32 UserTag;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("A Map Entity that the joint might be connected to.\nThe entity must have at least a Transform2D component.")]
    [Quantum.LocalReference]
    public global::EntityPrototype ConnectedEntity;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The anchor point to which the joint connects to.\nIf a Connected Entity is provided, this represents an offset in its local space. Otherwise, the connected anchor is a position in world space.")]
    public Photon.Deterministic.FPVector2 ConnectedAnchor;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The anchor offset, in the local space of this joint entity's transform.\nThis is the point considered for the joint constraints and where the forces will be applied in the joint entity's body.")]
    public Photon.Deterministic.FPVector2 Anchor;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)2, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The frequency in Hertz (Hz) at which the spring joint will attempt to oscillate.\nTypical values are below half the frequency of the simulation.")]
    public Photon.Deterministic.FP Frequency;
    [Quantum.Inspector.RangeAttribute((Single)0, (Single)2)]
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)2, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("A dimensionless value representing the damper capacity of suppressing the spring oscillation, typically between 0 and 1.")]
    public Photon.Deterministic.FP DampingRatio;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)1, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("Automatically configure the target Distance to be the current distance between the anchor points in the scene.")]
    public System.Boolean AutoConfigureDistance;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)2, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("AutoConfigureDistance", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)2)]
    [Quantum.Inspector.TooltipAttribute("The distance between the anchor points that the joint will attempt to maintain.")]
    public Photon.Deterministic.FP Distance;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)1, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("AutoConfigureDistance", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)2)]
    [Quantum.Inspector.TooltipAttribute("The minimum distance between the anchor points that the joint will attempt to maintain.")]
    public Photon.Deterministic.FP MinDistance;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)1, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("AutoConfigureDistance", (Int64)0, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)2)]
    [Quantum.Inspector.TooltipAttribute("The maximum distance between the anchor points that the joint will attempt to maintain.")]
    public Photon.Deterministic.FP MaxDistance;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("If the relative angle between the joint transform and its connected anchor should be limited by the hinge joint.\nSet this checkbox to configure the lower and upper limiting angles.")]
    public System.Boolean UseAngleLimits;
    [Quantum.Inspector.DegreesAttribute()]
    [Quantum.Inspector.DrawIfAttribute("UseAngleLimits", (Int64)1, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The lower limiting angle of the allowed arc of rotation around the connected anchor, in degrees.")]
    public Photon.Deterministic.FP LowerAngle;
    [Quantum.Inspector.DegreesAttribute()]
    [Quantum.Inspector.DrawIfAttribute("UseAngleLimits", (Int64)1, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The upper limiting  angle of the allowed arc of rotation around the connected anchor, in degrees.")]
    public Photon.Deterministic.FP UpperAngle;
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("If the hinge joint uses a motor.\nSet this checkbox to configure the motor speed and max torque.")]
    public System.Boolean UseMotor;
    [Quantum.Inspector.DegreesAttribute()]
    [Quantum.Inspector.DrawIfAttribute("UseMotor", (Int64)1, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The speed at which the hinge motor will attempt to rotate, in angles per second.")]
    public Photon.Deterministic.FP MotorSpeed;
    [Quantum.Inspector.DrawIfAttribute("UseMotor", (Int64)1, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.DrawIfAttribute("JointType", (Int64)3, (Quantum.Inspector.DrawIfCompareOperator)0, (Quantum.Inspector.DrawIfHideType)3)]
    [Quantum.Inspector.TooltipAttribute("The maximum torque produced by the hinge motor in order to achieve the target motor speed.\nLeave this checkbox unchecked and the motor toque should not be limited.")]
    public Photon.Deterministic.NullableFP MaxMotorTorque;

    public sealed override Quantum.Prototypes.Joint2D_Prototype Convert(EntityPrototypeConverter converter) {
      var result = new Quantum.Prototypes.Joint2D_Prototype();
      result.StartDisabled = this.StartDisabled;
      result.JointType = this.JointType;
      result.UserTag = this.UserTag;
      converter.Convert(this.ConnectedEntity, out result.ConnectedEntity);
      result.ConnectedAnchor = this.ConnectedAnchor;
      result.Anchor = this.Anchor;
      result.Frequency = this.Frequency;
      result.DampingRatio = this.DampingRatio;
      result.AutoConfigureDistance = this.AutoConfigureDistance;
      result.Distance = this.Distance;
      result.MinDistance = this.MinDistance;
      result.MaxDistance = this.MaxDistance;
      result.UseAngleLimits = this.UseAngleLimits;
      result.LowerAngle = this.LowerAngle;
      result.UpperAngle = this.UpperAngle;
      result.UseMotor = this.UseMotor;
      result.MotorSpeed = this.MotorSpeed;
      result.MaxMotorTorque = this.MaxMotorTorque;
      return result;
    }
  }

}
